# RISC-V swap example

## swap function

```c
#include <stdint.h>

void swap(uint64_t * x, uint64_t * y) {
  uint64_t a, b;
  a = * x;
  b = * y;
  if (a == b)
    return;
  * x = b;
  * y = a;
}
```

## Compile and disassemble swap library

Compile `swap.c` as a library, producing `swap.o`:

```shell
/path/to/riscv/bin/riscv64-unknown-linux-gnu-gcc -fno-stack-protector -c -o swap.o -O0 swap.c
```

Compile `swap.c` to assembly, producing `swap.s` (optional):
```shell
/path/to/riscv/bin/riscv64-unknown-linux-gnu-gcc -fno-stack-protector -O0 -S -o swap.s swap.c
```

Disassemble `swap.o`, producing `swap.da`:
```shell
/path/to/riscv/bin/riscv64-unknown-linux-gnu-objdump -d swap.o
```

## Lifting swap program to BIR

The following command inside SML/HOL4 lifts the disassembled code to BIR:

```sml
val _ = lift_da_and_store "swap" "swap.da" ((Arbnum.fromInt 0), (Arbnum.fromInt 0x1000000));
```

Parameters to the `lift_da_and_store` function are as follows:

- `"swap"`: string representing the name of the HOL4 term that will be
 defined to be equal to the translated BIR program
- `"./swap.da"`: path to the disassembled program
- `((Arbnum.fromInt 0), (Arbnum.fromInt 0x1000000))`: superset of the
  addresses that contains the program code. We call this memory region
  `UnmodifiableMemory`.

## BIR swap program and its properties

After lifting, the BIR program resides in the HOL4 term `bir_swap_prog`.
The program's BIR statements can be obtained by:

```sml
val blocks = (fst o listSyntax.dest_list o dest_BirProgram o snd o dest_eq o concl o EVAL) ``bir_swap_prog``;
```

Each block has a unique label (i.e. `BL_Address (Imm64 0w)`). In this
case the label is an integer, which is equal to the address of the
corresponding transpiled instruction. Labels can also be strings, for
example when the block represents internal computations of an
instruction or is generated by some program transformations (i.e. loop
unrolling).

A block has an internal list of statements, which are executed
sequentially. In this case there is only one statement, which decreases
the variable `SP_EL0` (of type `Bit64`) by `16`.

Finally, a block always ends with a control flow statement. In this
case, the block jumps to the next block, i.e. the block having label
`BL_Address (Imm64 4w)`. Notice that it is not possible to jump to the
middle of a block. 

`bir_swap_riscv_lift_THM` is the main theorem and states that the
program has been correctly transpiled, and has this statement:

```sml
bir_is_lifted_prog riscv_bmr (WI_end 0w 0x1000000w) bir_swap_progbin bir_swap_prog
```

See the definition of `bir_is_lifted_prog` for what the theorem means.

## Concrete execution of BIR program

To understand program behavior in BIR, we concretely execute the swap BIR program with
different parameters, including the number of BIR steps to take. For this we use the
(non-proof-producing) SML function `bir_exec_prog_print`.

```sml
val exec_swap_thm =
 bir_exec_prog_print "swap" bir_prog_reg n_max validprog_o welltypedprog_o state_o;
```

## Symbolic execution of BIR program
