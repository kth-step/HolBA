# HolBA-SE

This README describes the artifact for VMCAI 2026 paper 19, which
has the title "Forward Symbolic Execution for Trustworthy Automation
of Binary Code Verification". We refer to the artifact as HolBA-SE.

## Artifact overview

HolBA-SE is an extension of the HolBA library for binary analysis.
In turn, HolBA depends on the HOL4 theorem prover, implemented in
Standard ML (SML). HolBA-SE relies specifically on the Poly/ML compiler.

HolBA-SE directories are as follows:

- `scripts`: installation scripts
- `src`: SML sources for HolBA-SE library
- `examples/riscv`: SML sources for RISC-V application
- `examples/arm_cm0`: SML sources for ARM Cortex-M0 application
- `src_exectime`: sources for the ARM Cortex-M0 benchmark binary, the hardware testing harness, and the AbsInt aiT project files
- `logs`: contains the various logs for our verification applications, and also from hardware testing and AbsInt aiT runs

Notable subdirectories:

- `src/theory/tools/symbexec`: HOL4 symbolic execution theory, BIR instantiation
- `src/tools/symbexec`: SML functions for applying symbolic execution results
- `examples/riscv/chacha20`: ChaCha20 cipher case study
- `examples/riscv/kernel-trap`: RISC-V kernel case study

We estimate the artifact takes 1-2 hours to build and replicate
on a modern machine. We tested on an Intel Core i5-9600K with 32GB RAM.
Low RAM such as 8GB is unlikely to work.

## Getting Started Guide

### Alternative 1: using bundled Dockerfile

We provide a Dockerfile in the artifact root directory
(where this README resides) that can be used to bootstrap
and enter an environment for replicating results:

$ docker build -t holbase .
$ docker run -it --rm holbase

This takes 20-25 minutes on a modern machine and builds an x86 environment.
The second docker command enters the shell where step-by-step instructions
below can be run.

### Alternative 2: manual building

HolBA-SE can be replicated outside Docker by manually installing the following dependencies:

- Poly/ML, version 5.7.1 or later (https://github.com/polyml/polyml/releases)
- HOL4, tag trindemossen-1 (https://github.com/HOL-Theorem-Prover/HOL/releases/tag/trindemossen-1)
- Z3, version 4.14.1 (https://github.com/Z3Prover/z3/releases/tag/z3-4.14.1)

HolBA is then built using the "Holmake" tool bundled with HOL4. To let HolBA
know where to find the z3 binary, its path must be set via the environment:

$ export HOL4_Z3_EXECUTABLE=/path/to/bin/z3

Assuming Holmake is in the path, this should give an environment equivalent
to the Docker one in this shell.

## Step-by-Step Instructions for Replication

### 0. Building HolBA-SE

In the root directory (where this README resides), run:

$ Holmake

This takes 10-20 minutes on a modern machine.

The result should be output with lots of "OK".

### 1. HOL4 definitions and theorems

Machine-checked definitions and theorems in HOL4 have the SML type `thm`.
All of these definitions and theorems are checked in the previous step,
but they can be inspected for reassurance. This is easiest done by
starting a HOL4 toplevel from the root directory:

$ hol --holstate src/holba-heap

This will give a prompt starting with ">" that can be exited with Ctrl+d.

Using the prompt, Definition 1 (p. 6) can be inspected using:

> symb_recordTheory.symb_matchstate_def;

Theorem 1 (p. 7):

> bir_symb_soundTheory.birs_symb_step_sound_thm;

Definition 2 (p. 7):

> symb_recordTheory.symb_minimal_interpretation_def;

Definition 3:

> symb_recordTheory.symb_matchstate_ext_def;

Definition 4:

> symb_recordTheory.symb_hl_step_in_L_sound_def;

Theorem 2: 

> symb_prop_transferTheory.symb_prop_transfer_thm;

Figure 3 (p. 9):

(symbstep)

> symb_rulesTheory.symb_rule_STEP_thm;

(case)

> symb_rulesTheory.symb_rule_SPLIT_thm;

(infeasible)

> symb_rulesTheory.symb_rule_INF_thm;

(rename)

> symb_rulesTheory.symb_rule_SRENAME_thm;

(freesymb_rename)

> symb_rulesTheory.symb_rule_SRENAME_FREE_thm;

(subst)

> symb_rulesTheory.symb_rule_INST_thm;

Figure 4 (p. 10):

(simplify)

> symb_rulesTheory.symb_rule_FRESH_thm;

(consequence)

> symb_rulesTheory.symb_rule_CONS_thm;

(transfer)

> symb_rulesTheory.symb_rule_STRENGTHEN_thm;

(sequence)

> symb_rulesTheory.symb_rule_SEQ_thm;

### 2. Evaluation of symbolic execution (Table 1, p. 14)

Starting from the root directory, run:

$ cd examples/riscv && ./collect_experiment_data.py

This takes 5-10 minutes on a modern machine.

The final output should have symbolic execution time in seconds
for all example programs in Table 1. This data is also stored
in the file experiment_data.log. We provide a local sample of
experiment_data.log in logs/riscv/experiment_data.log for
comparison.

### 3. RISC-V functional verification case studies (Section 6)

To check the ChaCha20 cipher case study, start from the root directory and run:

$ cd examples/riscv/chacha20 && Holmake

This can take 5-10 minutes on a modern machine.

The output should include a bunch of "OK".

Key files that are checked:

- examples/riscv/chacha20/chachaScript.sml - abstract definition of ChaCha
- examples/riscv/chacha20/chacha20_spec_riscvScript.sml - ChaCha20 column round and diagonal round pre/postconditions
- examples/riscv/chacha20/chacha20_column_round_propScript.sml - ChaCha20 column round RISC-V contract (see near end of file)
- examples/riscv/chacha20/chacha20_diagonal_round_propScript.sml - ChaCha20 diagonal round RISC-V contract (see near end of file)

To check RISC-V kernel case study, start from the root directory and run:

$ cd examples/riscv/kernel-trap && Holmake

This can take 5-10 minutes on a modern machine.

The output should include a bunch of "OK".

Key files that are checked:

- examples/riscv/kernel-trap/kernel_trap_spec_riscvScript.sml - pre/postconditions
- examples/riscv/kernel-trap/kernel_trap_entry_propScript.sml - trap_entry RISC-V contract (see near end of file)
- examples/riscv/kernel-trap/kernel_trap_return_propScript.sml - trap_return RISC-V contract (see near end of file)

### 4. Cortex-M0 execution time verification case studies (Section 7)

Checking the execution time evaluations in Section consosts of two parts.

#### Reproducing verificaion results

To check the verification results using HolBA-SE, start from the root directory and run:

$ ./src_exectime/holba-se_run_all.sh

This takes about an hour on a modern machine.

The output should include a bunch of "OK".

Key files that are checked:

- examples/arm_cm0/tiny/tiny_analysisScript.sml - 
- examples/arm_cm0/aes/aes_o0_wholeScript.sml - 
- examples/arm_cm0/aes/aes_o0_loopScript.sml - 
- examples/arm_cm0/modexp_simple/modexp_asm_uidivmodScript.sml - 
- examples/arm_cm0/modexp_simple/modexp_asmScript.sml - 
- examples/arm_cm0/motor_set/motor_o0Script.sml - 
- examples/arm_cm0/motor_set/motor_o3Script.sml - 
- examples/arm_cm0/balrob/v2-faster/...Script.sml - 
- examples/arm_cm0/balrob/v2-faster/balrob_topScript.sml - 

The outputs of the verification tool reside in the various .hollogs directories and are automatically copied into the logs directory with simpler names. These files contain the execution times, the validated runtimes, and manually exctracted execution times for return instructions. Note that the validated runtimes have to be added together with the return times as they are not accounted for as symbolic execution stops before executing the return instructions.

#### Data from testing on hardware and AbsInt aiT tool

Reproducing the "aiT" column of Table 2 requires a proprietary tool and an appropriate license. In case this is not available, the logs directory contains our collected outputs. They are the same for the same binary even if the tool runs multiple times.

Reproducing the "testing" column of Table 2 requires a specialized hardware setup, which is described in the EmbExp-Box repository (https://github.com/kth-step/embexp-box). Given those in place, log collection is executed by the testing harness in src_exectime/testing/run_all_testing.sh.

